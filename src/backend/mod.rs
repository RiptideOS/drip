//! The backend of the compiler deals with the task of converting our target
//! agnostic LIR to asembly instructions for a specific platform. This is
//! generally a straightforward process since many LIR constructs can be
//! translated directly to assembly.

use std::{fs, io::BufRead, path::Path};

use itertools::Itertools;

use crate::{
    backend::targets::{CodeGenerator, Target},
    middle::lir,
};

pub mod assemblers;
pub mod targets;

#[derive(Debug, Default, Clone, Copy, PartialEq, Eq)]
pub enum OutputKind {
    Assembly,  // .S
    Object,    // .o
    StaticLib, // .a
    SharedLib, // .so / .dll / .dylib
    #[default]
    Executable, // ELF / Mach-O / PE
}

#[derive(Debug, Default)]
pub struct CodegenOptions {
    pub target: Option<Target>,
    pub output_kind: OutputKind,
    pub emit_debug_info: bool,
    pub verbose: bool,
}

#[derive(Debug)]
pub enum CodegenError {
    FileOutputFailure,
    TemporaryDirectoryCreationFailure,
    TemporaryFileCreationFailure,
    AssemblerError,
    LinkerError,
}

macro_rules! display_buffer {
    ($buffer:expr, $name:literal, $buf_name:literal) => {
        $buffer
            .lines()
            .map_while(Result::ok)
            .for_each(|line| println!("[{}] ({}): {}", $name, $buf_name, line));
    };
}

pub fn codegen_module(
    lir: &lir::Module,
    output_path: &Path,
    options: &CodegenOptions,
) -> Result<(), CodegenError> {
    let code_generator = options
        .target
        .unwrap_or(Target::x86_64LinuxGnu)
        .get_code_generator();

    /* Step 0. Create a temporary directtory to work in */

    const DRIP_TMP_PATH: &str = "/tmp/drip";

    // Create a temporary directory to work in
    let build_dir = fs::create_dir_all(DRIP_TMP_PATH)
        .and_then(|_| mktemp::Temp::new_dir_in(DRIP_TMP_PATH))
        .map_err(|_| CodegenError::TemporaryDirectoryCreationFailure)?
        .release();

    /* Step 1. Code Generation */

    // Create a temporary file to pass to the assembler
    let assembly_file_path = build_dir.join("program.s");

    // Dynamically generate the assembly based on the compile target's code generator
    let assembly = code_generator.translate_to_asm(lir, options);

    // Prepend the assembly with a header containing the compiler version number
    let assembly = format!(
        "; Generated by dripc (Drip Compiler) v{version}\n\n{file}",
        version = env!("CARGO_PKG_VERSION"),
        file = assembly
    );

    println!(
        "{}",
        assembly
            .lines()
            .enumerate()
            .map(|(i, line)| format!("{:3?}: {line}", i + 1))
            .join("\n")
    );

    // Write the assembly file to disk
    fs::write(&assembly_file_path, assembly)
        .map_err(|_| CodegenError::TemporaryFileCreationFailure)?;

    // If all we want is to generate asm, then write to disk and stop here
    if let OutputKind::Assembly = options.output_kind {
        fs::copy(assembly_file_path, output_path).map_err(|_| CodegenError::FileOutputFailure)?;
        return Ok(());
    }

    /* Step 2. Assembling */

    // Create a temporary file to pass to the linker
    let object_file_path = build_dir.join("program.o");

    // Invoke the assembler to create the object file
    let mut assembler_command =
        code_generator.create_assembler_command(&assembly_file_path, &object_file_path);

    let output = assembler_command
        .output()
        .expect("Could not invoke assembler!");

    if !output.status.success() {
        // Break on assembler error
        display_buffer!(output.stderr, "ASSEMBLER", "STDERR");
        return Err(CodegenError::AssemblerError);
    } else if options.verbose {
        // Print assembler output if verbose is passed
        display_buffer!(output.stdout, "ASSEMBLER", "STDOUT");
    }

    // If all we want is to generate an object file, then write to disk and stop here
    if let OutputKind::Object = options.output_kind {
        fs::copy(object_file_path, output_path).map_err(|_| CodegenError::FileOutputFailure)?;
        return Ok(());
    }

    /* Step 3. Linking */

    // Create a temporary file to pass to the linker
    let executable_file_path = build_dir.join("program");

    let mut linker_command =
        code_generator.create_linker_command(&object_file_path, &executable_file_path);

    let output = linker_command.output().expect("Could not invoke linker!");

    if !output.status.success() {
        // Break on linker error
        display_buffer!(output.stderr, "LINKER", "STDERR");
        return Err(CodegenError::LinkerError);
    } else if options.verbose {
        // Print linker output if verbose is passed
        display_buffer!(output.stdout, "LINKER", "STDOUT");
    }

    fs::copy(executable_file_path, output_path).map_err(|_| CodegenError::FileOutputFailure)?;

    /* Step 4. Celebrate! We compiled our program! */

    Ok(())
}
